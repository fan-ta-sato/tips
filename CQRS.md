# CQRS

- Command Query Responsibility Segregation：コマンドクエリ責務分離

## [CQRSとイベントソーシングの使用法、または「CRUDに何か問題でも？」](https://postd.cc/using-cqrs-with-event-sourcing/)


### コマンドとクエリ

- CRUDと違ってCQRSは、データの読み込みと書き込みは違うものだという前提にもとづく考えかたです。CQRSでは、データベースの操作をコマンド（データを書き換える操作）とクエリ（データを読み込む操作）の二つに分類します。コマンドは一般に、操作の成否以上の情報を呼び出し側に返しません。また、クエリは冪等であることが保証されます。間にコマンドが挟まらないという前提で、同じクエリを何度実行しても結果は同じになるということです。RESTでいうと、コマンドはPUTやPOSTに対応し、クエリはGETに対応するものです。
- QRSなら、エンティティのどのフィールドが更新可能なのかといった混乱はなくなります。コマンドには、そのコマンドに関連するフィールドだけを含めることになるからです。

### イベントソーシング

- コマンドは何らかの意図や要望（却下される可能性もあるもの）を表しますが、イベントは既に発生した事実を表します
    - ユーザーのメールアドレスを更新するコマンドが実行されてから、「メールアドレスが更新された」などというイベントが発生するのです。

- EventStoreは追記限定の不変なストリームとしてイベントを扱います

## [イベント・ソーシングを知る](https://www.slideshare.net/shuheifujita90/ss-14294169)

## [CQRS+ESについて細かい実装や考察をまとめてみた](http://edy.hatenablog.com/entry/2017/02/26/232244)

- Command側のフロー
  まずCommand側のフローとしては以下のようになっている
    1. ユーザーは任意のアクションを実行する
    1. クライアントがアクションをCommandとしてサーバーへ投げる。(例:名前の変更/ChangeName)
    1. サーバーがCommandを受け取る
    1. ドメインモデルがCommandを解釈し、ドメインに基づいた処理を実行する(例:名前を変更する)
    1. ドメインモデルは結果となるEventを生成する(例:名前が変更された/ChangedName)
    1. Eventを保存する
- Commandは指示、Eventは指示の結果として起きた出来事。

